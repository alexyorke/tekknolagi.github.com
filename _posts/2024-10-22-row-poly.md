---
title: Adding row polymorphism to Damas-Hindley-Milner
layout: post
---

## What is Damas-Hindley-Milner?

Damas-Hindley-Milner (HM) is a type system for the lambda calculus (later
adapted for Standard ML and the ML-family languages) with parametric
polymorphism, aka generic functions. It sits at a sweet spot in PL design: the
type system is quite expressive, and there are well known type inference
algorithms that require absolutely no annotations from the programmer.

River and I [wrote about it](/blog/type-inference) earlier this month. Check
out that post if you would like an introduction or refresher. In this post,
we'll add *row polymorphism* to it. We'll do it in the context of Algorithm J,
but the core ideas should be algorithm-independent.

## The main idea

## The data structures

## Let polymorphism

## Row polymorphism

Scrapscript has records (kind of like structs) and run-time row polymorphism.
This means that you can have a function that pulls out a field from a record
and any record with that field is a legal argument to the function.

See for example two different looking records (2D point and 3D point):

```
get_x left + get_x right
. left  = { x = 1, y = 2 }
. right = { x = 1, y = 2, z = 3 }
. get_x = | { x = x, ... } -> x
```

Hindley Milner doesn't come with support for this right out of the box. If you
add support for records, then you end up with a more rigid system: the records
have to have the same number of fields and same names of fields and same types
of fields. This is safe but overly restrictive.

I think it's possible to "easily" add row polymorphism but we haven't done it
yet. Finding a simple, distilled version of the ideas in the papers has so far
been elusive.

We're currently reading:

* [A Polymorphic Type System for Extensible Records and Variants](https://web.cecs.pdx.edu/~mpj/pubs/96-3.pdf) (PDF, 1996)
* [Extensible records with scoped labels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf) (PDF, 2005)
* [Extensible Programming with First-Class Cases](https://dl.acm.org/doi/pdf/10.1145/1159803.1159836) (PDF, 2006)
* [Set-Theoretic Types for Polymorphic Variants](https://dl.acm.org/doi/10.1145/2951913.2951928) (2016)
* [Generic programming in OCaml](https://arxiv.org/pdf/1812.11665) (PDF, 2018)
* [Abstracting extensible data types: or, rows by any other name](https://dl.acm.org/doi/pdf/10.1145/3290325) (PDF, 2019)
  * Incredible paper title
* [Structural Subtyping as Parametric Polymorphism](https://dl.acm.org/doi/abs/10.1145/3622836) (PDF, 2023)
* [Fast polymorphic record access](https://osa1.net/posts/2023-01-23-fast-polymorphic-record-access.html) (2023)

Please recommend additional papers, blog posts, and implementations.

## Variants

Scrapscript supports variants or tags similar to OCaml's notion of [polymorphic
variants](https://ocaml.org/manual/5.2/polyvariant.html). We don't have any
encoding in the type system for these right now.

We're currently reading:

* [Programming with Polymorphic Variants](https://caml.inria.fr/pub/papers/garrigue-polymorphic_variants-ml98.pdf) (PDF, 1998)
* [Restrictable Variants: A Simple and Practical Alternative to Extensible Variants](https://drops.dagstuhl.de/storage/00lipics/lipics-vol263-ecoop2023/LIPIcs.ECOOP.2023.17/LIPIcs.ECOOP.2023.17.pdf) (PDF, 2003)

Please recommend additional papers, blog posts, and implementations.

## Conclusion

## Acknowledgements

Thank you to [River Dillon Keefer](https://k-monk.org/) for co-authoring the
code and this post with me at [Recurse Center][rc].

[rc]: https://www.recurse.com/scout/click?t=e8845120d0b98bbc3341fa6fa69539bb

## See also
