---
title: WebAssembly compilers for free with weval
description: ""
---

[Chris Fallin](https://cfallin.org/) came and gave a talk to the Northeastern
[Programming Research Laboratory](https://prl.khoury.northeastern.edu/)
yesterday. He talked about his work on a new project called
[weval](https://github.com/cfallin/weval), a WebAssembly partial evaluator.

Partial evaluation is neat. In short, it's all about taking an existing
program, modifying it to hold some of its inputs as constants, and then letting
the compiler/optimizer go hog wild on it. The result is still a program---not a
value---and it's usually faster than the original program.

The usual small example is the power function. If you have a function that takes
two arguments, `x` and `y`, and returns `x^y`:

```c
int power(int x, int y) {
  int result = 1;
  for (int i = 0; i < y; i++) {
    result *= x;
  }
  return result;
}
```

If you partially evaluate this function with respect to `y` at `y = 5`, you get
a new function that takes one argument, `x`, and returns `x^5`:

```c
int power_5(int x) {
  int result = 1;
  for (int i = 0; i < 5; i++) {
    result *= x;
  }
  return result;
}
```

Now, to you, this might not look that different from the original function. But
to an optimizer, it is a new world of opportunity. The optimizer can unroll the
loop and remove the conditional:

```c
int power_5(int x) {
  return x * x * x * x * x;
}
```

weval does that for entire WebAssembly modules. WebAssembly modules that are
normally much bigger than a small `power` function. You might want to use it
if, for example, your WebAssembly module is an interpreter. Imagine a world
where you have compiled a runtime such as SpiderMonkey or CPython to
WebAssembly. You could then run your Python or JavaScript programs on the
WebAssembly runtime, but they would be slower than if you had compiled them
directly to WebAssembly.
